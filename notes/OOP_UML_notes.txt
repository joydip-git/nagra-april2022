1. OOP
	1. Inheitance
	2. Encapsulation: placing data members and functionalities together inside a class, is known as encapsulation
	3. data abstraction: hiding the data of an object (private)
	4. polymorphism

PIE theory

a. class, object
b. constructor and destructor
c. virtual and overriding
d. abstract class
e. interface

2. UML: Unified Modelling Language
	

Layered architecture: 3 tier architecture
	a. data access logic
	b. business logic
	c. presentation logic


Object:
	a. attributes or properties: gender, height, complexion, name etc. [data]
	b. behavior: run, jog, cook, sleep, write code, learn, read, write [functionalities]

name	height	
------------------------
akash	5.6   => object
animesh 5.10  => object
shruti  5.3   => object

{ name: "akash", height: 5.6 }
{ name: "akash", height: 5.6 }
{ name: "akash", height: 5.6 }


name, height, complexion, company, location, salary, edu-background, experience

account-holder-name, account-id, account-balance, type-account, minimum-balanace, withdrawal-limit
-------------------------------------------------------------------------------------------------------
akash			1	1000			savings	500			5000
abhishek		2	2000			current	0			10000	

create table(
account_id int,
acc_holder_name varchar(50),
acc_balance decimal(18,2),
type_acc varchar(10),
min_balance decimal(18,2),
with_limit decimal(18,2)
)

insert into table-name (column-names...) values(values...)

class name	attributes 		data-types
-----------------------------------------------------------------------------------------
account		acountid		int (numerical, non-fractional)
		accountholdername	string/char array
		accountbalance		decimal/float (numerical, fractional)
		accounttype		string/char array
		minimumbalance		decimal/float (numerical, fractional)
		withdrawallimit		decimal/float (numerical, fractional)

class account
{
	//fields, data members, attributes. characterestics
	private int acountid;
	public string accountholdername;
	private string accounttype;
	private float accountbalance;
	private float minimumbalance;
	private float withdrawallimit;

	~account()
	{
	}

	//default constructor: assigns default values to the data members
	public account()
	{
	}

	//parameterized constructor: assigns passed/parameter values to the data members
	//arguments of the function which are also local ti the function only
	public account(int id, string name, string type, float balance, float limit, float minbalance)
	{
		acountid = id;
		accountholdername = name;
		accounttype = type;
		accountbalance = balance;
		minimumbalance = minbalance;
		withdrawallimit = limit;
	}

        public int getAccountId()
	{
		return accountid;
	}

	//methods, functinalities, behaviors
	public float debitAmount(float amount)
	{
		int x = 10;
		accountbalance = accountbalance - amount;
		return accountbalance;
	}

	public void creditAmount(float amount)
	{
		accountbalance = accountbalance + amount;
		//return accountbalance;
	}
}

object => instance created based on the schema/blueprint known as class, which decides value for which attributes should be part of that object and which functionalities are part of that object

 akashObjRef = account() (python)
 //account akashObjRef; (C++)

 account akashObjRef =  new account(1,"akash","savings",1000, 10000,500); (C++, java, C#)
 akashObjRef.debitAmount(200);
 akashObjRef.creditAmount(300);

account devanadObjRef =  new account(2, "devanand","current",2000,20000,0);
//devanadObjRef.accountid=2
devanadObjRef.getAccountId();
devanadObjRef.debitAmount(200);
devanadObjRef.creditAmount(300);

devanadObjRef = null;

constructor?????:
	- special type of function, without any return type, NOT EVEN void and with the name same as that of a class
	- initialize the data members of the object
	- does not return anything
	- it is called during object creation (neither before, nor after, never called with the object reference)

1. runtime finds out the data members of the class
2. runtime allocates memory block for each of them
3. runtime puts default values in those memory blocks by invoking the constructor

4. upon creation of the object the initial address of the object is returned and assigned to a variable by runtime
5. now, with the reference/address of that object you can access other members of the object

destructor:

class filehandler/databasehandler
{
   string filePath;
   writeIntoFile(string data){}
   readFromFile(){}
}


access specifiers:







	